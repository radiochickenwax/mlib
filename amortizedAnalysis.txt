
Guidelines:
-----------
1. Each time an item is added to the array without requiring
   reallocation, count 1 unit of cost. This cost will cover the
   assignment which actually puts the item in the array. 

2. Each time an item is added and requires reallocation, count X + 1
   units of cost, where X is the number of items currently in the
   array. This cost will cover the X assignments which are necessary
   to copy the contents of the full array into a new (larger) array,
   and the additional assignment to put the item which did not fit
   originally. 

Analysis:
========
1. How many cost units are spent in the entire process of performing
   32 consecutive push operations on an empty array which starts out
   at capacity 8, assuming that the array will double in capacity each
   time a new item is added to an already full dynamic array? As N
   (ie. the number of pushes) grows large, under this strategy for
   resizing, what is the big-oh complexity for a push?  

By amortized analysis, the sum of costs are 56 with an avg cost of
1.75 shown in the following table.

The big-oh complexity is O(1)+.

|-------------+----------+---------+--------------+-----------|
| (N) push op | capacity | op cost | sum of costs |  avg cost |
|-------------+----------+---------+--------------+-----------|
|           1 |        8 |       1 |            1 |         1 |
|           2 |        8 |       1 |            2 |         1 |
|           3 |        8 |       1 |            3 |         1 |
|           4 |        8 |       1 |            4 |         1 |
|           5 |        8 |       1 |            5 |         1 |
|           6 |        8 |       1 |            6 |         1 |
|           7 |        8 |       1 |            7 |         1 |
|           8 |        8 |       1 |            8 |         1 |
|           9 |       16 |     8+1 |           17 | 1.8888889 |
|          10 |       16 |       1 |           18 |       1.8 |
|          11 |       16 |       1 |           19 | 1.7272727 |
|          12 |       16 |       1 |           20 | 1.6666667 |
|          13 |       16 |       1 |           21 | 1.6153846 |
|          14 |       16 |       1 |           22 | 1.5714286 |
|          15 |       16 |       1 |           23 | 1.5333333 |
|          16 |       16 |       1 |           24 |       1.5 |
|          17 |       32 |    16+1 |           41 | 2.4117647 |
|          18 |       32 |       1 |           42 | 2.3333333 |
|          19 |       32 |       1 |           43 | 2.2631579 |
|          20 |       32 |       1 |           44 |       2.2 |
|          21 |       32 |       1 |           45 | 2.1428571 |
|          22 |       32 |       1 |           46 | 2.0909091 |
|          23 |       32 |       1 |           47 | 2.0434783 |
|          24 |       32 |       1 |           48 |         2 |
|          25 |       32 |       1 |           49 |      1.96 |
|          26 |       32 |       1 |           50 | 1.9230769 |
|          27 |       32 |       1 |           51 | 1.8888889 |
|          28 |       32 |       1 |           52 | 1.8571429 |
|          29 |       32 |       1 |           53 | 1.8275862 |
|          30 |       32 |       1 |           54 |       1.8 |
|          31 |       32 |       1 |           55 | 1.7741935 |
|          32 |       32 |       1 |           56 |      1.75 |
#+TBLFM: $5=$4/$1



2. How many cost units are spent in the entire process of performing
   32 consecutive push operations on an empty array which starts out
   at capacity 8, assuming that the array will grow by a constant 2
   spaces each time a new item is added to an already full dynamic
   array? As N (ie. the number of pushes) grows large, under this
   strategy for resizing, what is the big-oh complexity for a push? 

For this scheme, the cost units spent are 260.  This is roughly a
big-oh complexity O(n).  One might also say it's O(n/x) depending on
precision where x is some number such as 4.  
|-------------+----------+---------+--------------+-----------+------+------|
| (N) push op | capacity | op cost | sum of costs |  avg cost |  n/4 |  n^2 |
|-------------+----------+---------+--------------+-----------+------+------|
|           1 |        8 |       1 |            1 |         1 | 0.25 |    1 |
|           2 |        8 |       1 |            2 |         1 |  0.5 |    4 |
|           3 |        8 |       1 |            3 |         1 | 0.75 |    9 |
|           4 |        8 |       1 |            4 |         1 |    1 |   16 |
|           5 |        8 |       1 |            5 |         1 | 1.25 |   25 |
|           6 |        8 |       1 |            6 |         1 |  1.5 |   36 |
|           7 |        8 |       1 |            7 |         1 | 1.75 |   49 |
|           8 |        8 |       1 |            8 |         1 |    2 |   64 |
|           9 |       10 |     8+1 |           17 | 1.8888889 | 2.25 |   81 |
|          10 |       10 |       1 |           18 |       1.8 |  2.5 |  100 |
|          11 |       12 |    10+1 |           29 | 2.6363636 | 2.75 |  121 |
|          12 |       12 |       1 |           30 |       2.5 |    3 |  144 |
|          13 |       14 |    12+1 |           43 | 3.3076923 | 3.25 |  169 |
|          14 |       14 |       1 |           44 | 3.1428571 |  3.5 |  196 |
|          15 |       16 |    14+1 |           59 | 3.9333333 | 3.75 |  225 |
|          16 |       16 |       1 |           60 |      3.75 |    4 |  256 |
|          17 |       18 |    16+1 |           77 | 4.5294118 | 4.25 |  289 |
|          18 |       18 |       1 |           78 | 4.3333333 |  4.5 |  324 |
|          19 |       20 |    18+1 |           97 | 5.1052632 | 4.75 |  361 |
|          20 |       20 |       1 |           98 |       4.9 |    5 |  400 |
|          21 |       22 |    20+1 |          119 | 5.6666667 | 5.25 |  441 |
|          22 |       22 |       1 |          120 | 5.4545455 |  5.5 |  484 |
|          23 |       24 |    22+1 |          143 | 6.2173913 | 5.75 |  529 |
|          24 |       24 |       1 |          144 |         6 |    6 |  576 |
|          25 |       26 |    24+1 |          169 |      6.76 | 6.25 |  625 |
|          26 |       26 |       1 |          170 | 6.5384615 |  6.5 |  676 |
|          27 |       28 |    26+1 |          197 | 7.2962963 | 6.75 |  729 |
|          28 |       28 |       1 |          198 | 7.0714286 |    7 |  784 |
|          29 |       30 |    28+1 |          227 | 7.8275862 | 7.25 |  841 |
|          30 |       30 |       1 |          228 |       7.6 |  7.5 |  900 |
|          31 |       32 |    30+1 |          259 | 8.3548387 | 7.75 |  961 |
|          32 |       32 |       1 |          260 |     8.125 |    8 | 1024 |


Side Note:
I found a contradictory explanation of this at
http://stackoverflow.com/questions/19146037/efficiency-of-growing-a-dynamic-array-by-a-fixed-constant-each-time 

Doubling the capacity:



    1 + 2 + 4 + 8 + 16 + 32 + ... + n

    = 1 + 2 + 4 + 8 + ... + 2log n

    = 2log n + 1 - 1

    = 2n - 1

    = Θ(n)

Increasing the capacity by a constant:


    (c + c) + (2c + c) + (3c + c) + ... + (n + c)

    = cn / c + (c + 2c + 3c + ... + nc / c)

    = n + c(1 + 2 + 3 + ... + n / c)

    = n + c*(n/c)*(n/c + 1)/2

    = n + n*(n/c + 1)/2

    = n + (n^2 / c) + n / 2

    = Θ(n^2)


3. Suppose that a dynamic array stack doubles its capacity when it is
   full, and shrinks (on Pop only) its capacity by half when the array
   is half full or less. Can you devise a sequence of N push() and
   pop() operations which will result in poor performance (O(N^2)
   total cost)? How might you adjust the array's shrinking policy to
   avoid this? (Hint: You may assume that the initial capacity of the
   array is N/2.) 


I'm not sure what's right and wrong here.  I think there is a big
difference between amortized analysis and asymptotic analysis. 

Devising a sequence of push() and pop() that results in poor
performance isn't difficult.  Most algorithms that come to mind will
have poorer perfomance than simply doubling the capacity without
halving it. 

The first thing that comes to mind is the following:

// stack.capacity = n/2;

// adding n/2 elements is a O(n) task.

for (i = 0; i < (int)n/2; i++)
 push(stack,element);  // O(1), stack.capacity = n after this

// the capacity is now doubled (2n) and a call to pop() will 
// cause the capacity to be halved which is also O(n).

// O(n) * O(n) = O(n^2)

What's more difficult is finding an algorithm that will not be O(N^2).


